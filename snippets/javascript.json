{
	"Print to console": {
		"prefix": "log vscode-pwa author",
		"body": [
			"$1",
			"console.log('Authored by Maye Edwin');",
			"$1"
		],
		"description": "Authorship to console!"
	},

	"Service Worker": {
		"prefix": "basic service worker",
		"body": [
			"$1",
			"self.addEventListener('fetch', function(event) {",
			"event.respondWith(caches.open('cache').then(function(cache) {",
			"return cache.match(event.request).then(function(response) {",
			"console.log(\"cache request: \" + event.request.url);",
			"var fetchPromise = fetch(event.request).then(function(networkResponse) { ",
			"// if we got a response from the cache, update the cache ",
			"console.log(\"fetch completed: \" + event.request.url, networkResponse);",
			"if (networkResponse) {",
			" console.debug(\"updated cached page: \" + event.request.url, networkResponse);",
			"   cache.put(event.request, networkResponse.clone());}",
			"   return networkResponse;},",
			"// rejected promise - just ignore it, we're offline! ",
			"     console.log(\"Error in fetch()\", event);",
			"     event.waitUntil(caches.open('cache').then(function(cache) {",
			" // our cache is named *cache* in the caches.open() above",
			"     return cache.addAll ([ ",
			"      '/', // do not remove this",
			"      '/index.html', // cache index page",
			"      '/images/*',// choose images to keep offline, just an example",
			"      ]);",
			"   })",
			"  );",
			"});",
			" // respond from the cache, or the network",
			"return response || fetchPromise;",
			"});",
			"}));",
			" });",
			"$1",
			"self.addEventListener('install', function(event) {",
			"   self.skipWaiting();",
			"   console.log(\"Latest version installed!\");",
			"});",
			"$1"
		],
		"description": "Basic Service Worker"
	},

	"workbox-cli": {
		"prefix": "workbox-cli devDependencies",
		"body": [
			"$1",
			"\"workbox-cli\": \"^3.0.1\"",
			"$1"
		],
		"description": "workbox-cli"
	},

	"workbox injectManifest": {
		"prefix": "workbox injectManifest",
		"body": [
			"$1",
			"&& workbox injectManifest sw-config.js",
			"$1"
		],
		"description": "workbox injectManifest"
	},

	"Precache for node": {
		"prefix": "precache for node",
		"body": [
			"$1",
			"module.exports = {",
			"\"globDirectory\": \"build/\", // the base directory you wish to match globPatterns against,",
			"\"globPatterns\": [",
			"// edit to add all file to cache;",
			"\"**/*.css\", // eg cache all css files, images etc in the root folder",
			"\"index.html\", // cache index page",
			"\"app.webmanifest\",",
			"/* add more assets or",
			"     resources to cache */",
			"\"swSrc\": \"src/service-worker.js\", // the path and filename of the Service Worker file that will be created by the build process.",
			"\"globIgnores\": [",
			"\"../sw-config.js\"",
			"$1",
			"]",
			"};"
		],
		"description": "Precache for node"
	},

	"Workbox": {
		"prefix": "import workbox",
		"body": [
			" importScripts('https://storage.googleapis.com/workbox-cdn/releases/4.1.1/workbox-sw.js');",
			" if (workbox) {",
			"   console.log('[ PWA Fire Bundle ] Hello from Workbox');",
			"$2",
			"$2",
			"     /* add workbox cache",
			"          strategies */",
			"$2",
			"$2",
			"   workbox.core.skipWaiting();",
			"   workbox.core.clientsClaim();",
			" } else {",
			"   console.log('Boo! Workbox failed to load ðŸ˜¬');",
			" }"
		]
	},

	"Workbox cache strategies": {
		"prefix": "workbox.strategies",
		"body": [
			"$1",
			"/*change strategy method to fit your pwa needs,",
			"  update RegExp dir/route and cache name*/",
			"workbox.routing.registerRoute(",
			"   new RegExp('talks/'),",
			"   new workbox.strategies.StaleWhileRevalidate({",
			"     cacheName: 'talks/',",
			"     plugins: [",
			"      new workbox.cacheableResponse.Plugin({",
			"       statuses: [0, 200],",
			"      }),",
			"      new workbox.expiration.Plugin({",
			"       maxAgeSeconds: 60 * 60 * 24 * 1,",
			"      }),",
			"    ],",
			"  })",
			");",
			"$1"
		],
		"description": "Workbox cache strategies"
	},

	"StaleWhileRevalidate": {
		"prefix": "StaleWhileRevalidate",
		"body": [
			"StaleWhileRevalidate"
		],
		"description": "Stale-While-Revalidate"
	},

	"CacheFirst": {
		"prefix": "CacheFirst",
		"body": [
			"CacheFirst"
		],
		"description": "Cache First (Cache Falling Back to Network)"
	},
	
	"NetworkFirst": {
		"prefix": "NetworkFirst",
		"body": [
			"NetworkFirst"
		],
		"description": "Network First (Network Falling Back to Cache)"
	},

	"NetworkOnly": {
		"prefix": "NetworkOnly",
		"body": [
			"NetworkOnly"
		],
		"description": "Network Only"
	},
	
	"CacheOnly": {
		"prefix": "CacheOnly",
		"body": [
			"CacheOnly"
		],
		"description": "Cache Only"
	}
}